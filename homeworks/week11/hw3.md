## 請說明雜湊跟加密的差別在哪裡，為什麼密碼要雜湊過後才存入資料庫

截自網路：「並不是人看不懂的東西就稱作『加密』，如果誤用的話，很有可能自以為加密了的東西，根本就沒有經過加密處理，隨隨便便就可以被了解解密方式的人拿到寶貴的原始文字。」

#### 加密

加密的核心是要有一把鑰匙，原先的資料上鎖。實體上的運作有點像是函式，比如說 `ABC` 的密碼經過 +3 這把鑰匙，結果會輸出成 `DEF` 任何知道這把鑰匙的人都能夠經過逆向處理得到原先的密碼。 

這種能夠透過「一把鑰匙」同時加密與解密的方式稱作「對稱式加密」。

而對稱式加密的問題也很簡單，要不是鑰匙弄丟，不然就是鑰匙太簡單被駭客猜中。再來另一個問題是，在網路環境中，雙方若要能加密解密，就一定要有同一把鑰匙，不過在網路世界中將鑰匙給對方，本身就有被中間人得知的風險，一旦有第三者得知鑰匙，那不管加密演算法再複雜都沒有用。

像是 `AES` ，即是一種對稱式加密的實例，其 key 的組合多達 10³⁸ 種。

為了彌補對稱式加密的缺點與問題，因此有另一種加密方式稱為「非對稱式加密」。

「非對稱式加密」與「對稱式加密」的差別在於，前者擁有「公鑰」與「私鑰」兩把鑰匙，公鑰加密後的內容只能以私鑰解開。

比方說 A 要將資料傳送給 B，B可以產生一組 Key 並將公鑰傳給 A，然後 A 再將資料以公鑰加密後傳送給 B，B 再以同一組 key 裡的私鑰解開，由於私鑰一直在 B 手上，因此若第三者取得公鑰仍無法解開密碼。最有名的實例為 `RSA`。

#### 雜湊

雜湊與加密最大的不同，就在於無法從輸出解回輸入，雜湊的進行是單向不可逆的。

其特性有下列幾點：
1. 不論輸入長度為多少，都會輸出固定長度的結果。
2. 輸入只要差一個字，輸出的結果就會截然不同。
3. 儘管雜湊是單向不可逆，但只要是同個雜湊函式與同樣的輸入，一定會得到相同的輸出。
4. 不同的輸入有可能得出相同的輸出，這稱作「碰撞」。

然而，因為相同輸入會有相同的輸出，因此可以透過暴力解的方式，將各種輸入與輸出統整成一張「彩虹表」。為了防止這種情況，通常在雜湊時會在原始資料上加「鹽」（額外加入的值），因此得到的雜湊值會是「原始資料＋鹽」的組合，儘管雜湊函式被破解，得到的也只是加鹽後的結果，而非原始資料。

由於雜湊是無法從輸出倒回輸入，所以實際上的用途主要在於「驗證」。若經過雜湊後的結果不相符，則可以推敲出資料可能錯誤、毀損，或是遭人篡改。

另一個實際的情況是，通常你去任何網站註冊會員，若忘記密碼，對方都會請你重新設定，而非把你原本的密碼寄還給你。其實，就連他們也不知道你當初設定的密碼，只能透過再次輸入的密碼確認是否與當初相同，才給你重新設定的權限。因為若對方存明碼，只要資料庫被駭客攻擊，就可能密碼明碼外洩。

常見的雜湊演算法有： `SHA系列`, `MD5` 等。其中 `SHA-1` 與 `MD5` 已被證實不夠安全，也就是說在可接受的時間內，找得到碰撞發生。

[參考資料一](https://blog.m157q.tw/posts/2017/12/23/differences-between-encryption-compression-and-encoding/)

[參考資料二](https://medium.com/starbugs/what-are-encoding-encrypt-and-hashing-4b03d40e7b0c)

## `include`、`require`、`include_once`、`require_once` 的差別

##### `include`: 直接將 `include` 的檔案程式碼載入到目的地檔案中

比如說有一支 A 檔案（head.php）程式碼如下：

```
<html>
<head>
測試<hr>
</head>
```

B 檔案（body.php）程式碼如下：

```
<?php include("head.php");?>
<body>
　<p>網頁內容</p>
</body>
</html>
```

那麼解析的結果就等於 A 檔案的程式碼直接複製過來，如：

```
<html>
<head>
測試<hr>
</head>
<body>
　<p>網頁內容</p>
</body>
</html>
```

##### `require`: 

與 `include` 基本相同，但處理錯誤的方式不同。當錯誤發生（如檔案遺失）時， `include` 會產生 `E_WARNING` 並繼續執行程式；而 `require` 會產生 `E_COMPILE_ERROR`，並停止執行程式。

另一個不同之處是， `require` 通常置於 PHP 檔案的開頭，在執行檔案前就先引入；而 `include` 則是放在程式的流程控制中，若程式需要時才引入，簡化流程。

##### `include_once`, `require_once`: 

會先檢查要引入的檔案是否已被引入過，若是已引入過則不會重複引入。由於 PHP 不允許相同名稱的函式被重複宣告，可避免重複引入相同名稱的函式所發生的錯誤。

[參考資料](https://www.runoob.com/php/php-includes.html)

[參考資料](https://www.wibibi.com/info.php?tid=243)

## 請說明 SQL Injection 的攻擊原理以及防範方法

`SQL Injection` 主要是在程式執行 SQL 指令時，由於沒有檢查特殊字元，導致惡意輸入的字串被解讀為正常的 SQL 指令，因此可以入侵伺服器。

SQL 指令基本上由查詢、插入、更新、刪除等命令的字元「串接」組成，同時也可以 `--`, `/**/` 註解文字，而命令中的字串參數則是以 `''` 包裹。因此若未針對特定字元跳脫處理，則會被解讀成正常的 SQL 指令。

例如：

```
$SQL = "SELECT * FROM users WHERE (user_name = '') and (user_pwd = '');"
```

正常使用者若輸入名稱為 admin，密碼為 adminpwd 時，SQL 會正常執行取出所有的資料。

但駭客可以在 pwd 的欄位輸入 `XXXX' or '1' = '1`，透過前後兩個獨立的單引號，則會使 SQL 指令變成 `$SQL = "SELECT * FROM users WHERE (user_name = '') and (user_pwd = 'XXXX' or '1' = '1')"`。

> 無論什麼密碼，最後都會得到邏輯為真的結果。實際上指令的執行會變成 `SQL = "SELECT * FROM users;"`

##### SQL Injection 防範方式

可以傳入參數的方式取代原先的字串拼接，用 PHP 內建的函式實作。

比方說可修改 SQL 指令： `$SQL = "INSERT INTO users(user_name, user_pwd) VALUES(?, ?)"`

1. 將原先需插入值的地方以 `?` 取代
2. `$stmt = $conn->prepare($SQL)`
3. `$stmt->bind_param('ss', $user_name, $user_pwd)` 傳入所需的值，除了 `s` 外，也可以 `i` 傳入數字。
4. `$result = $stmt->execute()`

##  請說明 XSS 的攻擊原理以及防範方法

`XSS` 同樣也是駭客透過「惡意輸入」，使得原本應該正常輸入的欄位的值，被程式解讀成他自己的一部份，以至於誤解語意而執行。而 `XSS` 與 `SQL Injection` 不同的地方在於，前者惡意輸入的程式語言為 `JavaScript`；而後者則是透過 `SQL 指令`。

`XSS` 攻擊主要分成三類：儲存型、映射型、以及 DOM 型。

##### 儲存型 XSS

只要是使用者輸入的資料，會儲存在資料庫中，以至於每次網頁讀取時都會觸發惡意程式碼的這種形式，就稱為儲存型 XSS。常見於論壇文章、留言板等。

比方說在沒有防範惡意程式碼的 `input`, `button` 中，輸入 `<script>alert("ATTACKED")</script>` ，則每次網頁讀取時都會執行這段程式碼。

##### 映射型 XSS

此種型態的攻擊，是基於表單以 `GET` 方式傳送資料時，將惡意程式碼塞入網址，以 `query string` 的方式攻擊，由於映射型的攻擊都會反映在網址上，仔細注意就可避免攻擊。

有一網址為接受輸入名字的參數，如 `/test.php?name=hello`，此時在 `query string` 中塞入 `<script>alert("ATTACKED")</script>`，同樣可觸發攻擊。

##### DOM 型 XSS

DOM 為動態操控 HTML 的一種表示方法，這一型態的攻擊主要是透過惡意輸入，更改網頁上的 DOM 元素，從而達到攻擊目的。

如有一 `input` 需使用者輸入暱稱，那麼我們可以在 `button` 綁上一個新增 DOM 元素的程式碼，而 DOM 元素的目的是要顯示出使用者剛剛輸入的暱稱。

如：
```
var name = document.querySelector('name').value;
document.querySelector('getName').innerHTML = name;
```

##### XSS 危險性

前面所提到的攻擊，都只是輸出 alert 或是顯示名字等無關緊要的資訊。但其實可以透過 XSS 取得使用者的帳號、密碼、代表身份的 cookie 等。

##### XSS 防範方式

> XSS 攻擊的關鍵是「使用者輸入的資料，被程式解讀成它的一部份」。

因此，防範的原理就是「不要讓程式將使用者輸入的資料解讀成程式」。

最常見的方法，就是利用跳脫字元，比方說將 `< 取代成 &lt;`, `& 取代成 &amp;` 等等。如 PHP 內建的函式 `htmlspecialchars()`。這樣瀏覽器在解讀使用者輸入的資料時，就不會將特殊文字解讀成程式語言，而只會當成純文字處理。

## 請說明 CSRF 的攻擊原理以及防範方法

`CSRF` 全名為 `Cross Site Request Forgery`，顧名思義就是「透過不同 `domain` 偽造使用者的 `request`」的攻擊方式。瀏覽器是怎麼判斷 `A Request` 與 `B Request` 是由同一個使用者發出的呢？是透過 `cookie` 及 `session` 去判斷使用者的狀態，因此 `CSRF` 就是將代表使用者身份的 `cookie` 或是 `session` 偷走，偽裝成你的身份從而對瀏覽器發出假的 `request`。

攻擊的原理是透過 `a`, `img`, `iframe` 等方式，將惡意的 `request` 藏在裡面，可能使用者在 A 網頁，卻在不知情的情況下發出了 B 網頁的刪除 `request`，而由於瀏覽器只認 `cookie`, `session` 不認人，會將這個刪除的 `request` 當作使用者本人發出的，如此一來你明明在 A 網頁，卻更動到了 B 網頁的資訊，你說是不是很可怕！既然可以刪除資料，同理洩漏密碼、未知情的轉帳也都能做到！

##### CSRF 防範方式

既然 `CSRF` 稱作 `CSRF`，就是因為他是透過 A 網頁去更動 B 網頁的內容，兩者的差別在於 A, B 網頁其實是在不同的 `domain` 之下。

###### REFERER

在 request 的 header 中有一個欄位稱作 `referer`，可以得知 `request` 是由哪一個 `domain` 發出，因此可以透過 `referer` 這個欄位去阻擋非法的 `domain` ，或是只讓合法的 `domain` 通過。

不過用這個方式去過濾攻擊，其實是不太完善的，因為 `referer` 不一定每一個瀏覽器都有提供，使用者也可能關閉 `referer` 的功能，又或是說駭客可以偽裝子 `domain` 鑽到漏洞。

###### CSRF Token

另一個防禦方式，可以在表單中新增 `name='csrftoken' value='隨機亂碼'`，亂碼由 server 產生及儲存，並且每一次的 session 都會更新。

不過駭客可以先提前發出 `request` 取得這個 token，再來偽造使用者身份，因此也沒有很安全。

##### SameSite cookie

前面提到的，都是在使用者端所做的防禦，那麼瀏覽器端是否也可以做些事情呢？

有的，而且很簡單，就是「在 cookie 上再多做一層防護」就好。只有在當前此網站的 domain 才帶有這個 cookie，其他網站所發出的 request 都不會有。

只要在設置 cookie 時加上：
```
Set-Cookie: key=value; path=/; domain=example.org; HttpOnly; SameSite=Lax
```
而 SameSite cookie 提供兩種屬性，分別是 `Strict` 以及 `Lax`。

為什麼要有這兩種屬性呢？因為 `CSRF` 是跨站的攻擊，不過有些時候使用者也會發出跨站的請求，例如從購物網站跳轉至付費頁面，又或是說玩遊戲連動帳戶登入的功能等等，如果每一次使用者本人發出跨站請求，都需要重新登入，是不是很麻煩？這兩種模式主要是為了解決這個問題，而提供的。

`Strict`：此種模式會過濾所有如 `<a>`, `<from>` 等發出的跨站請求，只要不是同個 `domain` 發出的請求，一律不會帶有 cookie，也就是說要重新登入的意思，如果是付款這種敏感資訊就算了，但如果是無關緊要的跨站請求都要重新登入，會嚴重影響使用者體驗，因此我們可以設定成 `Lax` 模式，這種模式可以接受 `<a>`, `<link>`, `<form method='GET'>`等跨站請求。

>  要注意的是，`POST, PUT, DELETE` 等方法也同樣沒辦法取得 `cookie`。同理，由於可以接受 `GET` 的跨站請求，因此沒辦法阻擋 `GET` 的 `CSRF` 攻擊。

[參考資料一](https://blog.techbridge.cc/2017/02/25/csrf-introduction/)
[參考資料二](https://yakimhsu.com/project/project_w12_Info_Security-CSRF.html)